<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="target/&#10;!.mvn/wrapper/maven-wrapper.jar&#10;!**/src/main/**/target/&#10;!**/src/test/**/target/&#10;&#10;### IntelliJ IDEA ###&#10;.idea/modules.xml&#10;.idea/jarRepositories.xml&#10;.idea/compiler.xml&#10;.idea/libraries/&#10;*.iws&#10;*.iml&#10;*.ipr&#10;&#10;### Eclipse ###&#10;.apt_generated&#10;.classpath&#10;.factorypath&#10;.project&#10;.settings&#10;.springBeans&#10;.sts4-cache&#10;&#10;### NetBeans ###&#10;/nbproject/private/&#10;/nbbuild/&#10;/dist/&#10;/nbdist/&#10;/.nb-gradle/&#10;build/&#10;!**/src/main/**/build/&#10;!**/src/test/**/build/&#10;&#10;### VS Code ###&#10;.vscode/&#10;&#10;### Mac OS ###&#10;.DS_Store" />
              <option name="updatedContent" value="target/&#10;!.mvn/wrapper/maven-wrapper.jar&#10;!**/src/main/**/target/&#10;!**/src/test/**/target/&#10;&#10;### IntelliJ IDEA ###&#10;.idea/modules.xml&#10;.idea/jarRepositories.xml&#10;.idea/compiler.xml&#10;.idea/libraries/&#10;*.iws&#10;*.iml&#10;*.ipr&#10;&#10;### IntelliJ Data Sources (local, don't commit credentials) ###&#10;.idea/dataSources.local.xml&#10;.idea/dataSources.xml&#10;&#10;### Eclipse ###&#10;.apt_generated&#10;.classpath&#10;.factorypath&#10;.project&#10;.settings&#10;.springBeans&#10;.sts4-cache&#10;&#10;### NetBeans ###&#10;/nbproject/private/&#10;/nbbuild/&#10;/dist/&#10;/nbdist/&#10;/.nb-gradle/&#10;build/&#10;!**/src/main/**/build/&#10;!**/src/test/**/build/&#10;&#10;### VS Code ###&#10;.vscode/&#10;&#10;### Mac OS ###&#10;.DS_Store" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.idea/dataSources.local.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.idea/dataSources.local.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;data-sources version=&quot;21&quot;&gt;&#10;  &lt;data-source&gt;&#10;    &lt;name&gt;Embedded Postgres (playlist-merge)&lt;/name&gt;&#10;    &lt;driver-ref&gt;PostgreSQL&lt;/driver-ref&gt;&#10;    &lt;url&gt;jdbc:postgresql://localhost:5432/postgres&lt;/url&gt;&#10;    &lt;user&gt;postgres&lt;/user&gt;&#10;    &lt;password&gt;postgres&lt;/password&gt;&#10;    &lt;keep-password&gt;true&lt;/keep-password&gt;&#10;  &lt;/data-source&gt;&#10;&lt;/data-sources&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/amazonmusic/scraper/CsvService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/amazonmusic/scraper/CsvService.java" />
              <option name="originalContent" value="package com.amazonmusic.scraper;&#10;&#10;import com.opencsv.CSVWriter;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.util.List;&#10;&#10;/**&#10; * Service for exporting song data to CSV files using OpenCSV.&#10; * Handles safe string conversion and logging.&#10; * &#10; * @author Amazon Music Scraper Team&#10; * @since 1.0&#10; */&#10;public class CsvService implements CsvServiceInterface {&#10;    private static final Logger logger = LoggerFactory.getLogger(CsvService.class);&#10;&#10;    /**&#10;     * Writes a list of songs to a CSV file.&#10;     * @param songs List of Song records to export&#10;     * @param filename Output CSV filename&#10;     * @throws IOException if file writing fails&#10;     */&#10;    public void writeSongsToCSV(List&lt;Song&gt; songs, String filename) throws IOException {&#10;        if (songs == null) {&#10;            logger.warn(&quot;Attempted to write null song list to CSV: {}&quot;, filename);&#10;            throw new IllegalArgumentException(&quot;Song list cannot be null&quot;);&#10;        }&#10;        if (filename == null || filename.trim().isEmpty()) {&#10;            logger.warn(&quot;Attempted to write CSV with invalid filename: {}&quot;, filename);&#10;            throw new IllegalArgumentException(&quot;Filename cannot be null or empty&quot;);&#10;        }&#10;        try (CSVWriter writer = new CSVWriter(new FileWriter(filename))) {&#10;            writer.writeNext(new String[]{&#10;                &quot;Title&quot;, &quot;Artist&quot;, &quot;Album&quot;, &quot;URL&quot;, &quot;Duration&quot;, &quot;TrackNumber&quot;, &quot;PlaylistPosition&quot;, &quot;Explicit&quot;, &quot;ImageURL&quot;, &quot;ReleaseDate&quot;, &quot;Genre&quot;&#10;            });&#10;            for (Song song : songs) {&#10;                writer.writeNext(new String[]{&#10;                    safe(song.title()),&#10;                    safe(song.artist()),&#10;                    safe(song.album()),&#10;                    safe(song.url()),&#10;                    safe(song.duration()),&#10;                    song.trackNumber() == null ? &quot;&quot; : song.trackNumber().toString(),&#10;                    song.playlistPosition() == null ? &quot;&quot; : song.playlistPosition().toString(),&#10;                    song.explicit() == null ? &quot;&quot; : song.explicit().toString(),&#10;                    safe(song.imageUrl()),&#10;                    safe(song.releaseDate()),&#10;                    safe(song.genre())&#10;                });&#10;            }&#10;        }&#10;        logger.info(&quot;Wrote {} songs to CSV file: {}&quot;, songs.size(), filename);&#10;    }&#10;&#10;    /**&#10;     * Safely converts a string for CSV output, removing commas and newlines.&#10;     * @param s Input string&#10;     * @return Sanitized string&#10;     */&#10;    private static String safe(String s) {&#10;        // Replace commas with space and collapse any CR/LF characters into a single space, then trim&#10;        return s == null ? &quot;&quot; : s.replace(&quot;,&quot;, &quot; &quot;).replaceAll(&quot;[\\r\\n]+&quot;, &quot; &quot;).trim();&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.amazonmusic.scraper;&#13;&#10;&#13;&#10;import com.opencsv.CSVWriter;&#13;&#10;import org.slf4j.Logger;&#13;&#10;import org.slf4j.LoggerFactory;&#13;&#10;&#13;&#10;import java.io.FileWriter;&#13;&#10;import java.io.IOException;&#13;&#10;import java.nio.file.Files;&#13;&#10;import java.nio.file.Path;&#13;&#10;import java.nio.file.Paths;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;/**&#13;&#10; * Service for exporting song data to CSV files using OpenCSV.&#13;&#10; * Handles safe string conversion and logging.&#13;&#10; * &#13;&#10; * @author Amazon Music Scraper Team&#13;&#10; * @since 1.0&#13;&#10; */&#13;&#10;public class CsvService implements CsvServiceInterface {&#13;&#10;    private static final Logger logger = LoggerFactory.getLogger(CsvService.class);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Writes a list of songs to a CSV file.&#13;&#10;     * @param songs List of Song records to export&#13;&#10;     * @param filename Output CSV filename&#13;&#10;     * @throws IOException if file writing fails&#13;&#10;     */&#13;&#10;    public void writeSongsToCSV(List&lt;Song&gt; songs, String filename) throws IOException {&#13;&#10;        if (songs == null) {&#13;&#10;            logger.warn(&quot;Attempted to write null song list to CSV: {}&quot;, filename);&#13;&#10;            throw new IllegalArgumentException(&quot;Song list cannot be null&quot;);&#13;&#10;        }&#13;&#10;        if (filename == null || filename.trim().isEmpty()) {&#13;&#10;            logger.warn(&quot;Attempted to write CSV with invalid filename: {}&quot;, filename);&#13;&#10;            throw new IllegalArgumentException(&quot;Filename cannot be null or empty&quot;);&#13;&#10;        }&#13;&#10;        // ensure scraped-data directory exists and write files into it&#13;&#10;        try {&#13;&#10;            Path outDir = Paths.get(&quot;scraped-data&quot;);&#13;&#10;            if (!Files.exists(outDir)) Files.createDirectories(outDir);&#13;&#10;            filename = outDir.resolve(filename).toString();&#13;&#10;        } catch (IOException e) {&#13;&#10;            logger.warn(&quot;Failed to ensure scraped-data directory exists: {}. Will attempt to write to current directory.&quot;, e.getMessage());&#13;&#10;        }&#13;&#10;        try (CSVWriter writer = new CSVWriter(new FileWriter(filename))) {&#13;&#10;            writer.writeNext(new String[]{&#13;&#10;                &quot;Title&quot;, &quot;Artist&quot;, &quot;Album&quot;, &quot;URL&quot;, &quot;Duration&quot;, &quot;TrackNumber&quot;, &quot;PlaylistPosition&quot;, &quot;Explicit&quot;, &quot;ImageURL&quot;, &quot;ReleaseDate&quot;, &quot;Genre&quot;&#13;&#10;            });&#13;&#10;            for (Song song : songs) {&#13;&#10;                writer.writeNext(new String[]{&#13;&#10;                    safe(song.title()),&#13;&#10;                    safe(song.artist()),&#13;&#10;                    safe(song.album()),&#13;&#10;                    safe(song.url()),&#13;&#10;                    safe(song.duration()),&#13;&#10;                    song.trackNumber() == null ? &quot;&quot; : song.trackNumber().toString(),&#13;&#10;                    song.playlistPosition() == null ? &quot;&quot; : song.playlistPosition().toString(),&#13;&#10;                    song.explicit() == null ? &quot;&quot; : song.explicit().toString(),&#13;&#10;                    safe(song.imageUrl()),&#13;&#10;                    safe(song.releaseDate()),&#13;&#10;                    safe(song.genre())&#13;&#10;                });&#13;&#10;            }&#13;&#10;        }&#13;&#10;        logger.info(&quot;Wrote {} songs to CSV file: {}&quot;, songs.size(), filename);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Safely converts a string for CSV output, removing commas and newlines.&#13;&#10;     * @param s Input string&#13;&#10;     * @return Sanitized string&#13;&#10;     */&#13;&#10;    private static String safe(String s) {&#13;&#10;        // Replace commas with space and collapse any CR/LF characters into a single space, then trim&#13;&#10;        return s == null ? &quot;&quot; : s.replace(&quot;,&quot;, &quot; &quot;).replaceAll(&quot;[\\r\\n]+&quot;, &quot; &quot;).trim();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>